Q. new 와 malloc에 대해 설명하시오 

Q. 아래와 같은 상황에서 어디에서 오류가 발생하는가? 왜 그런지 설명하시오 

	1 : int* pa = new int;
	2 : delete pa;
	3 : delete pa;
	4 : pa = nullptr;
	5 : pa = new int;
	6 : int doit = 2;
	7 : int* pb = &doit;
	8 : delete pb;

Q. malloc과 new 언제 사용하는가?

Q. calloc, malloc, realloc, new의 차이점에 대해 설명하시오 

Q. 메모리 할당이 제대로 되지 못한 상황에서 new의 동작반응에 대해 설명하시오 

Q. 구조체 안에 string이 있을경우 malloc을 통한 할당이 가능한가 ? 

-------------------------------------------------

Q. new 와 malloc에 대해 설명하시오 
A.	new
	정의 : 객체 생성 시 생성자 호출과 함께 메모리를 할당하며, 자동으로 타입을 결정.
	기능 : 객체 생성 + 동적 메모리 할당	
	크기 명시 : 명시 필요 없음	
	타입 : 	반환값이 지정된 타입	
	생성자 호출 : 생성자 호출	
	메모리 해제 : delete 연산자로 해제 - 소멸자 호출이 아님 / 메모리에서 할당된 블록을 해제하는 역할 
	연산자 vs 함수 : 연산자, 컴파일러에 의해 처리
	오버로딩 가능 여부 : 오버로딩 가능 (operator new)
	안전성 : 타입 안전	
	예외 처리 : 메모리 부족 시 예외(std::bad_alloc) 발생	

	malloc
	정의 : 객체 생성 시 생성자 호출과 함께 메모리를 할당하며, 자동으로 타입을 결정.
	기능 : 동적 메모리 할당만 수행
	타입 : 반환값이 void* 타입 (캐스팅 필요)
	생성자 호출 : 생성자 호출 불가
	메모리 해제 : free() 함수로 해제
	연산자 vs 함수 : 함수, 라이브러리 호출
	오버로딩 가능 여부 : 오버로딩 불가
	안전성 : 타입 안전하지 않음
	크기 명시 : 명시적으로 크기를 전달해야 함	
	예외 처리 : 메모리 부족 시 NULL 반환

	MyClass* obj = (MyClass*)malloc(sizeof(MyClass));
	int* ptr = (int*)malloc(sizeof(int));


	malloc은 C에서 사용되는 동적할당 키워드로 생성자가 없어서 동적할당을 할 때 쓰레기값이 들어가게됩니다. 
	반면 new는 c++에서 사용하는 동적할당 키워드로 생성자를 통해 동적할당되기때문에 프로그래머가 임의적으로 초기화를 진행할 수 있습니다. 
	
-------------------------------------------------

Q. 아래와 같은 상황에서 어디에서 오류가 발생하는가? 왜 그런지 설명하시오 
A.	3 : 이미 메모리를 해제했기때문에 또다시 해제하려고 하면 double-free문제가 발생합니다. 
	8 : pb는 동적 메모리가 아니라 정적 변수인 doit을 가리키고 있으므로 delete할 수 없다. 
		// 다르게 이야기하자면
		delete는 반드시 동적으로 할당된 메모리(new)에만 사용해야합니다. heap메모리 관리 목적으로 만들어졌기 때문인데 
		int doit = 2 로 스택메모리에 저장되기때문에 delete를 사용하여 메모리를 해제할 수 없습니다. 
	(-> 	스택메모리 함수이기때문에 함수가 끝나면 자동으로 해제되어 따로 해제할 필요가 없습니다. )
	
-------------------------------------------------

Q. malloc과 new 언제 사용하는가?
A. 일반적으로 new가 더 안전하지만, 메모리의 재할당이 빈번하게 발생하는경우 malloc을 사용합니다. 
	예를들어, 메모리 풀의 경우 동적 할당/해제 가 매우 빈번하게 일어나는데,
	malloc의 경우 realloc을 통해 메모리 크기를 동적으로 조정할 수 있어 malloc이 더 효과적일 수 있습니다. 
	
-------------------------------------------------

Q. calloc, malloc, realloc, new의 차이점에 대해 설명하시오 
A. 	malloc = 동적할당
		
		메모리 할당 : O
		초기화 : X
		반환타입 : void*
		기타 : 함수 호출시 할당하고자 하는 메모리의 크기를 바이트 단위로 전달하면 그 크기만큼 메모리를 할당하게 된다.
		실패시 NULL리턴

	calloc = 동적할당
		메모리 할당 : O / 연속적 메모리공간
		초기화 : 0으로 초기화 
		반환타입 : void*
		기타 : calloc은 할당된 공간의 값을 모두 0으로 바꾼다.

	realloc = 기존 메모리 크기 조정
		메모리 할당 : O
		초기화 : 기존메모리는 유지 + 추가부분 초기화 x
		반환타입 : void*
		기타 :  새로운 위치에 메모리를 할당하고 데이터를 복사합니다. 이전 메모리 블록은 자동으로 free됩니다.

	new = c++ 동적할당
		메모리 할당 : O
		초기화 : o
		반환타입 : 해당타입의 포인터 
		기타 : 생성자 호출
		
-------------------------------------------------

Q.	메모리 할당이 제대로 되지 못한 상황에서 new의 동작반응에 대해 설명하시오 
A.	
	동작방식
		1. 메모리 할당 실패 발생:
			new 연산자는 힙 메모리 할당에 실패하면 현재 등록된 new-handler를 호출합니다.
		2. new-handler의 반환 여부:
			new-handler가 성공적으로 메모리를 확보하거나 할당 실패를 복구하면, 다시 메모리 할당을 시도합니다.
			new-handler가 아무 작업도 수행하지 못하거나 예외를 던지면, 최종적으로 bad_alloc 예외가 발생합니다.
		3. 이후작업 - set_new_handler 사용:
			std::set_new_handler를 사용하여 사용자 정의 new-handler를 등록합니다.
			이 함수는 이전에 설정된 new-handler를 반환하며, 필요 시 복구 작업을 수행할 수 있습니다.

	예외처리방법
		1. try-catch
		2. set_new_handler : 사용자 지정 new handler지정
		3. nothrow : nullptr 반환.
		
	예시코드
		1. try-catch
			try {
				int *arr = new int[100000000];
			}
			catch (std::bad_alloc &exception) {
				cout << "exception :" << exception.what() << endl;
				std::abort();
			}
		
		2. set_new_handler
			void handler() {
				cout << "out of mem" << endl;
				std::abort();
			}

			int main(void) 
			{
				std::set_new_handler(handler);
				while (true) {
					int *arr = new int[100000000];
				}
				return 0;
			}

		3. nothrow
			int main(void) 
			{
				while (true) 
				{
					int *arr = new(std::nothrow) int[100000000];
					if (arr == NULL) 
					{
						cout << "NULL return" << endl;
						std::abort();
					}
				}
				return 0;
			}
	
-------------------------------------------------

Q. 구조체 안에 string이 있을경우 malloc을 통한 할당이 가능한가 ? 
A. malloc이 메모리 블록을 할당하려고 하지만 string의 경우 초기화하지 않고 사용하면 프로그램이 오작동할 수 있습니다.
